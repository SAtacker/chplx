/*
 * Copyright (c) 2023 Hartmut Kaiser
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#include "hpx/codegenvisitor.hpp"
#include "hpx/symboltypes.hpp"
#include "hpx/util.hpp"

#include "chpl/uast/all-uast.h"

#include <variant>
#include <fstream>
#include <cctype>
#include <numeric>
#include <type_traits>
#include <filesystem>

#define INDENT "    "

using namespace chpl::uast;

// emit line directive
void emitLineDirective(std::filesystem::path const& p, int line);

namespace chpl { namespace ast { namespace visitors { namespace hpx {

CodegenVisitor::CodegenVisitor(
   chpl::ast::visitors::hpx::SymbolTable & st,
   std::vector< Symbol > & configVars,
   ProgramTree & prgmTree,
   chpl::uast::BuilderResult const& chapelBr,
   std::string const& cppFilePath,
   std::string const& chapelFilePath,
   std::ostream & fstrm)
   : symbolTable(st), cfgVars(configVars), programTree(prgmTree), br(chapelBr),
     indent(0), scope(0),
     fstrm_(fstrm),
     cppFilePathStr(cppFilePath),
     chplFilePathStr(chapelFilePath),
     headers(static_cast<std::size_t>(HeaderEnum::HeaderCount), false)
{
}

static void upper(std::string & s) {
   std::transform(std::begin(s), std::end(s), std::begin(s), 
      [](const unsigned char c){ return std::toupper(c); } // correct
   );
}

void CodegenVisitor::generateApplicationHeader(std::filesystem::path const& chplpth) {
   const auto pos = chplFilePathStr.find(".");
   std::string prefix = chplFilePathStr.substr(0, pos);

   std::fstream os(prefix + ".hpp", std::ios_base::out);
   upper(prefix);

   os << "// This program file was generated by the chplx compiler." << std::endl
   << "// The original Chapel program file can be found here: " << chplpth.filename() << std::endl
   << "//" << std::endl
   << "#pragma once" << std::endl << std::endl
   << "#ifndef __" << prefix << "_HPP__" << std::endl
   << "#define __" << prefix << "_HPP__" << std::endl << std::endl
   << "#include <chplx.hpp>" << std::endl;

   for(std::size_t i = 0; i < static_cast<std::size_t>(HeaderEnum::HeaderCount); ++i) {
      if(headers[i]) {
         if(i == static_cast<std::size_t>(HeaderEnum::std_vector)) {
            os << "#include <vector>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_complex)) {
            os << "#include <complex>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_string)) {
            os << "#include <string>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_iostream)) {
            os << "#include <iostream>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_functional)) {
            os << "#include <functional>" << std::endl;
         }
      }
   }

   os << std::endl << "#endif" << std::endl;

   os.flush();
   os.close();
}

struct FuncDeclArgVisitor {

   template<typename T>
   void operator()(T const&) {
   }
   void operator()(bool_kind const& kind) {
      os << "bool";
   }
   void operator()(byte_kind const&) {
      os << "std::uint8_t";
   }
   void operator()(int_kind const&) {
      os << "std::int64_t";
   }
   void operator()(real_kind const&) {
      os << "double";
   }
   void operator()(complex_kind const&) {
      os << "std::complex<double>";
   }
   void operator()(string_kind const&) {
      os << "std::string";
   }
   void operator()(nil_kind const&) {
      os << "void";
   }

   std::ostream & os;
};

struct ExprVisitor {
    template<typename T>
    void operator()(T const&) {}

    void operator()(ScalarDeclarationLiteralExpression const& node) {
       node.emit(os);
    }
    void operator()(LiteralExpression const& node) {
       node.emit(os);
    }
    void operator()(VariableExpression const& node) {
       node.emit(os);
    }
    void operator()(std::shared_ptr<FunctionCallExpression> const& node) {
       node->emit(os);
    }
    void operator()(std::shared_ptr<BinaryOpExpression> const& node) {
       if(node->statements.size() == 2) {
          const bool lop = std::holds_alternative<std::shared_ptr<BinaryOpExpression>>(node->statements[0]);
          const bool rop = std::holds_alternative<std::shared_ptr<BinaryOpExpression>>(node->statements[1]);

          if(lop) {
             os << "( ";
          }

          std::visit(ExprVisitor{os}, node->statements[0]);

          if(lop) {
             os << " )";
          }

          os << ' ' << node->op << ' ';

          if(rop) {
             os << "( ";
          }

          std::visit(ExprVisitor{os}, node->statements[1]);

          if(rop) {
             os << " )";
          }
       }
       else if(node->statements.size() == 1) {
          os << ' ' << node->op;
          std::visit(ExprVisitor{os}, node->statements[0]);
       }
    }

    std::ostream & os;
};

struct StatementVisitor {
   
   void emitIndent() const {
      for(std::size_t i = 0; i < indent; ++i) {
         os << INDENT; 
      }
   }

   template <typename T>
   constexpr void operator()(T const& kind) {}

   void operator()(std::shared_ptr<StatementList> const& node) {
      auto & list = *node;
      for(auto & stmt : list.statements) {
         std::visit(*this, stmt); 
      }
   }
   void operator()(ScalarDeclarationExpression const& node) {
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
   }
   void operator()(ArrayDeclarationExpression const& node) {
      headers[static_cast<std::size_t>(HeaderEnum::std_vector)] = true;

      std::shared_ptr<array_kind> const& akref =
         std::get<std::shared_ptr<array_kind>>(node.kind);

      if(!headers[static_cast<std::size_t>(HeaderEnum::std_complex)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_complex)] =
            std::holds_alternative<complex_kind>(akref->kind);
      }
      if(!headers[static_cast<std::size_t>(HeaderEnum::std_string)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_string)] =
            std::holds_alternative<string_kind>(akref->kind);
      }

      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
   }
   void operator()(ScalarDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
      os << " = ";
      if( 0 < node.literalValue.size() ) {
         if(s->isConfig) {
             os << "config_" << s->identifier;
         }
         else {
             std::visit(ScalarDeclarationLiteralExpressionVisitor{s->literal[0], os}, node.kind);
         }

         os << ";" << std::endl;
      }
   }
   void operator()(ArrayDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
   }
   void operator()(VariableExpression const& node) {
      if(arg) {
         node.emit(os);
      }
   }
   void operator()(std::shared_ptr<ConditionalExpression> const& node) {
      for(std::size_t i = 0; i < node->exprs.size(); ++i) {
         if(printChplLine) {
            emitIndent();
            emitChapelLine(os, node->exprs[i].node);
         }
         emitIndent();
         os << ( (i == 0) ? "if" : ( (0 < node->exprs[i].conditions.size()) ?  "else if" : "else" ) );
         printChplLine = false;
         arg = true;
         if(0 < node->exprs[i].conditions.size()) {
            os << '(';
            visit(*this, node->exprs[i].conditions[0]);
            os << ")";
         }
         printChplLine = true;
         arg = false;
         os << "{" << std::endl;
         ++indent;
         for(const auto& stmt : node->exprs[i].statements) {
            visit(*this, stmt);
         }
         --indent;
         emitIndent();
         os << "}" << std::endl;
      }
   }
   void operator()(std::shared_ptr<ForLoopExpression> const& node) {
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();

      range_kind const& rk = std::get<range_kind>(node->indexSet.kind);
      os << "chplx::forLoop(chplx::Range{" << rk.points[0] << ", " << rk.points[1] << "}, [&](auto " << node->iterator.identifier << ") {" << std::endl;
      ++indent;
      for(const auto& stmt : node->statements) {
         visit(*this, stmt);
      }
      --indent;
      emitIndent();
      os << "});" << std::endl;
   }
   void operator()(std::shared_ptr<ForallLoopExpression> const& node) {
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();

      range_kind const& rk = std::get<range_kind>(node->indexSet.kind);
      os << "chplx::forall(chplx::Range{" << rk.points[0] << ", " << rk.points[1] << "}, [&](auto " << node->iterator.identifier << ") {" << std::endl;
      ++indent;
      for(const auto& stmt : node->statements) {
         visit(*this, stmt);
      }
      --indent;
      emitIndent();
      os << "});" << std::endl;
   }
   void operator()(std::shared_ptr<CoforallLoopExpression> const& node) {
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();

      range_kind const& rk = std::get<range_kind>(node->indexSet.kind);
      os << "chplx::coforall(chplx::Range{" << rk.points[0] << ", " << rk.points[1] << "}, [&](auto " << node->iterator.identifier << ") {" << std::endl;
      ++indent;
      for(const auto& stmt : node->statements) {
         visit(*this, stmt);
      }
      --indent;
      emitIndent();
      os << "});" << std::endl;
   }
   void operator()(std::shared_ptr<ReturnExpression> const& node) {
      emitIndent();
      os << node->chplLine;
      emitIndent();
      node->emit(os);
   }
   void operator()(std::shared_ptr<FunctionCallExpression> const& node) {
      const bool is_cxx = std::holds_alternative<std::shared_ptr<cxxfunc_kind>>(node->symbol.kind);
      if(is_cxx) {
         headers[static_cast<std::size_t>(HeaderEnum::std_iostream)] = true;
      }
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();
      node->emit(os);
      if(!is_cxx) {
         os << ';' << std::endl;
      }
   }
   void operator()(std::shared_ptr<FunctionDeclarationExpression> const& node) {
      headers[static_cast<std::size_t>(HeaderEnum::std_functional)] = true;

      if(node->symbol.identifier.size() < 1) { std::cerr << "codegenvisitor.cpp FunctionDeclarationExpression " << node->symbol.identifier << " not found" << std::endl; }

      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
         emitIndent();
      }

      if(std::holds_alternative<std::shared_ptr<func_kind>>(node->symbol.kind)) {
         std::shared_ptr<func_kind> const& fk =
            std::get<std::shared_ptr<func_kind>>(node->symbol.kind);

         FuncDeclArgVisitor fdav{os};
         const std::size_t args_sz = fk->args.size()-1;

         os << "auto ";
         std::string const& fn_sig_ref =
            node->symbol.identifier;

         const std::size_t pos =
            fn_sig_ref.find("|");

         os << fn_sig_ref.substr(0, (pos != std::string::npos) ? pos : fn_sig_ref.size() ) << " = [&](";

         if(0 < args_sz) {
            std::visit(fdav, fk->args[0].kind);
            os << ' ' << fk->args[0].identifier;

            for(std::size_t i = 1; i < args_sz; ++i) {
               os << ',';
               std::visit(fdav, fk->args[i].kind );
               os << ' ' << fk->args[i].identifier;
            }
         }

         if(std::holds_alternative<nil_kind>(fk->retKind)) {
            os << ")";
         }
         else {
            os << ") -> ";
            std::visit(fdav, fk->retKind);
         }
         os << " {";
         os << std::endl;
         ++indent;
         for(const auto& stmt : node->statements) {
            visit(*this, stmt);
         }
         --indent;
         emitIndent();
         os << "};" << std::endl;
      }
   }
   void operator()(std::shared_ptr<UnaryOpExpression> const& node) {
      emitIndent();
      node->emit(os);
      emitIndent();
   }
   void operator()(std::shared_ptr<BinaryOpExpression> const& node) {
      if(printChplLine) {
         emitIndent();
         emitChapelLine(os, node->ast);
      }

      if(!arg) {
         emitIndent();
      }
      std::visit(ExprVisitor{os}, node->statements[0]);

      os << ' ' << node->op << ' ';

      std::visit(ExprVisitor{os}, node->statements[1]);

      if(!arg) {
         os << ';' << std::endl;
      }
   }
   void operator()(std::shared_ptr<ScalarDeclarationExprExpression> const& node) {
      std::optional<Symbol> s = symbolTable.find(node->scopeId, node->identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationExprExpression " << node->identifier << " not found" << std::endl; }

      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }

      emitIndent();
      node->emit(os);
      os << " = ";

      std::visit(ExprVisitor{os}, node->statements[0]);

      if(!arg) {
         os << ';' << std::endl;
      }
   }
   void emitChapelLine(std::ostream & os, uast::AstNode const* ast) const {
      auto const fp = br.filePath();
      os << chplx::util::emitLineDirective(fp.c_str(), br.idToLocation(ast->id(), fp).line());
   }

   SymbolTable & symbolTable;
   chpl::uast::BuilderResult const& br;
   std::ostream & os;
   std::size_t indent;
   std::vector<bool> & headers;
   bool printChplLine;
   bool arg;
};

template<>
void CodegenVisitor::visit(StatementVisitor && v) {
   for(Statement const& stmt : programTree.statements) {
      std::visit(v, stmt);
   }
}

static void generateSourceHeader(std::vector<Symbol> & cfgVars, std::ostream & fos, std::string const& fps, std::string const& chplFile) {
   fos << "// This program file was generated by the chplx compiler." << std::endl;
   fos << "// The original Chapel program file can be found here: " << chplFile << std::endl;
   fos << "//" << std::endl;
            
   fos << "#include <hpx/hpx_init.hpp>" << std::endl << std::endl;
         
   {        
      const auto pos = fps.find(".");
      const std::string prefix = fps.substr(0, pos);
      fos << "#include \"" << prefix << ".hpp\"" << std::endl;
   }        

   if(0 < cfgVars.size()) {
      fos << std::endl;
      fos << "// global `config` variables" << std::endl <<  "//" << std::endl;
      for(auto & opt : cfgVars) {
         FuncDeclArgVisitor v{fos};
         std::visit(v, opt.kind);
         fos << ' ' << "config_" << opt.identifier;
         if(opt.isConfig && 0 < opt.literal.size()) {
             fos  << " = ";
             std::visit(ScalarDeclarationLiteralExpressionVisitor{opt.literal[0], fos}, opt.kind);
         }
         fos << ';' << std::endl;
      }
   }
}     
   
static void generateSourceFooter(std::vector<Symbol> & cfgVars, std::ostream & fos) {
   fos << std::endl
       << "int main(int argc, char * argv[]) {" << std::endl;

   if(0 < cfgVars.size()) {
      fos << "    hpx::program::options::options::options_description options;\n    options.add_options()";
      for(auto & opt : cfgVars) {
         fos << std::endl << "        (\"" << opt.identifier << "\"," << std::endl;
         FuncDeclArgVisitor v{fos};
         fos << "            hpx::program_options::value<";
         std::visit(v, opt.kind);
         fos << ">(&" << "config_" << opt.identifier << "), " << "\"config var " << opt.identifier << " : "; 
         std::visit(v, opt.kind);
         fos << "\")";
      }
      fos << ';' << std::endl;
      fos << "    hpx::init_params init_args;" << std::endl << "    init_args.desc_cmdline = options;" << std::endl;
   }

   fos << "    return hpx::init(argc, argv" << ((0 < cfgVars.size()) ? ", init_args" : "") <<  ");" << std::endl
       << "}" << std::endl;
}        
   
static void generateHpxMainBeg(std::ostream & fos)  {
   fos << std::endl
       << "int hpx_main(int argc, char * argv[]) {" << std::endl
       << std::endl;
}

static void generateHpxMainEnd(std::ostream & fos) {
   fos << std::endl
       << "    return hpx::finalize();" << std::endl
       << "}" << std::endl;
}


void CodegenVisitor::visit() {

   generateSourceHeader(cfgVars, fstrm_, cppFilePathStr, chplFilePathStr);

   generateHpxMainBeg(fstrm_);

   visit(StatementVisitor{symbolTable, br, fstrm_, indent, headers, true, false});

   generateHpxMainEnd(fstrm_);
   generateSourceFooter(cfgVars, fstrm_);
}

} /* namespace hpx */ } /* namespace visitors */ } /* namespace ast */ } /* namespace chpl */
