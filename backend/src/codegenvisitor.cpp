/*
 * Copyright (c) 2023 Hartmut Kaiser
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#include "hpx/codegenvisitor.hpp"
#include "chpl/uast/all-uast.h"

#include <variant>
#include <fstream>
#include <cctype>
#include <numeric>
#include <type_traits>

#define INDENT "    "

using namespace chpl::uast;
 
namespace chpl { namespace ast { namespace visitors { namespace hpx {

CodegenVisitor::CodegenVisitor(
   chpl::ast::visitors::hpx::SymbolTable & st,
   ProgramTree & prgmTree,
   chpl::uast::BuilderResult const& chapelBr,
   std::string const& chapelFilePath,
   std::ostream & fstrm)
   : br(chapelBr), programTree(prgmTree), indent(0), scope(0), fstrm_(fstrm),
     chplFilePathStr(chapelFilePath),
     symbolTable(st),
     headers(static_cast<std::size_t>(HeaderEnum::HeaderCount), false)
{
}

static void upper(std::string & s) {
   std::transform(std::begin(s), std::end(s), std::begin(s), 
      [](const unsigned char c){ return std::toupper(c); } // correct
   );
}

void CodegenVisitor::generateApplicationHeader() {
   const auto pos = chplFilePathStr.find(".");
   std::string prefix = chplFilePathStr.substr(0, pos);

   std::ofstream os{prefix + ".hpp"};
   upper(prefix);

   os << "// This program file was generated by the chplx compiler." << std::endl;
   os << "//" << std::endl;
   os << "#pragma once" << std::endl << std::endl;
   os << "#ifndef __" << prefix << "_HPP__" << std::endl;
   os << "#define __" << prefix << "_HPP__" << std::endl << std::endl;

   for(std::size_t i = 0; i < static_cast<std::size_t>(HeaderEnum::HeaderCount); ++i) {
      if(headers[i]) {
         if(i == static_cast<std::size_t>(HeaderEnum::std_vector)) {
            os << "#include <vector>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_complex)) {
            os << "#include <complex>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_string)) {
            os << "#include <string>" << std::endl;
         }
      }
   }

   os << std::endl << "#endif" << std::endl;

   os.flush();
   os.close();
}

struct ScalarDeclarationLiteralExpressionVisitor {
    template<typename T>
    void operator()(T const&) {}

    void operator()(bool_kind const& kind) {
       os << " = " << std::boolalpha << dynamic_cast<BoolLiteral const*>(ast)->value() << ";" << std::endl;
    }
    void operator()(byte_kind const&) {
       os << " = " << dynamic_cast<BytesLiteral const*>(ast)->value() << ";" << std::endl;
    }
    void operator()(int_kind const&) {
       os << " = " << dynamic_cast<IntLiteral const*>(ast)->value() << ";" << std::endl;
    }
    void operator()(real_kind const&) {
       os << " = " << std::fixed << dynamic_cast<RealLiteral const*>(ast)->value() << ";" << std::endl;
    }
    void operator()(complex_kind const&) {
       os << "std::complex<double>";
    }
    void operator()(string_kind const&) {
       os << "{\"" << dynamic_cast<StringLiteral const*>(ast)->value() << "\"}" << ";" << std::endl;
    }

    uast::AstNode const* ast;
    std::ostream & os;
};

struct StatementVisitor {
   
   void emitIndent() const {
      for(std::size_t i = 0; i < indent; ++i) {
         os << INDENT; 
      }
   }

   template <typename T>
   constexpr void operator()(T const& kind) {}

   void operator()(std::shared_ptr<StatementList> const& node) {
      auto & list = *node;
      for(auto & stmt : list.statements) {
         std::visit(*this, stmt); 
      }
   }
   void operator()(ScalarDeclarationExpression const& node) {
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }
   void operator()(ArrayDeclarationExpression const& node) {
      headers[static_cast<std::size_t>(HeaderEnum::std_vector)] = true;

      std::shared_ptr<array_kind> const& akref =
         std::get<std::shared_ptr<array_kind>>(node.kind);

      if(!headers[static_cast<std::size_t>(HeaderEnum::std_complex)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_complex)] =
            std::holds_alternative<complex_kind>(akref->kind);
      }
      if(!headers[static_cast<std::size_t>(HeaderEnum::std_string)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_string)] =
            std::holds_alternative<string_kind>(akref->kind);
      }

      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }
   void operator()(ScalarDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
      std::visit(ScalarDeclarationLiteralExpressionVisitor{(*s->literal)[0], os}, node.kind);
   }
   void operator()(ArrayDeclarationLiteralExpression const& node) {
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }

   SymbolTable & symbolTable;
   chpl::uast::BuilderResult const& br;
   std::ostream & os;
   std::size_t indent;
   std::vector<bool> & headers;
};

template<>
void CodegenVisitor::visit(StatementVisitor && v) {
   for(Statement const& stmt : programTree.statements) {
      std::visit(v, stmt);
   }
}

void CodegenVisitor::visit() {
   visit(StatementVisitor{symbolTable, br, fstrm_, indent, headers});
}

/*
bool CodegenVisitor::enter(const uast::AstNode * ast) {
   switch(ast->tag()) {
    case asttags::Variable:
    {
       //const std::string prefix = std::string{ast->id().symbolPath().c_str()};
       //const std::string name = std::string{dynamic_cast<NamedDecl const*>(ast)->name().c_str()};
       //std::optional<Symbol> sym = symbolTable.scopedFind(prefix + "." + name);

       std::string ident{dynamic_cast<NamedDecl const*>(ast)->name().c_str()};
       //std::optional<Symbol> sym = symbolTable.scopedFind(ident);
       std::optional<Symbol> sym = symbolTable.find(scope, ident);

       if(!sym->literalAssigned) {
           emit(ast, sym);
           identifier.reset();
       }
       else {
           identifier = ident;
       }
    }
    break;
    case asttags::BoolLiteral:
    case asttags::ImagLiteral:
    case asttags::IntLiteral:
    case asttags::RealLiteral:
    case asttags::UintLiteral:
    case asttags::BytesLiteral:
    case asttags::CStringLiteral:
    case asttags::StringLiteral:
    {
       //std::optional<Symbol> s = symbolTable.scopedFind(*identifier);
       std::optional<Symbol> s = symbolTable.find(scope, *identifier);
       if(s) {
           emit_literal(ast, s);
           identifier.reset();
       }
    }
    break;
    default:
    break;
   }

   return true;
}

*/

} /* namespace hpx */ } /* namespace visitors */ } /* namespace ast */ } /* namespace chpl */
