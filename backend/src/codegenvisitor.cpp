/*
 * Copyright (c) 2023 Hartmut Kaiser
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#include "hpx/codegenvisitor.hpp"
#include "hpx/symboltypes.hpp"
#include "chpl/uast/all-uast.h"

#include <variant>
#include <fstream>
#include <cctype>
#include <numeric>
#include <type_traits>

#define INDENT "    "

using namespace chpl::uast;
 
namespace chpl { namespace ast { namespace visitors { namespace hpx {

CodegenVisitor::CodegenVisitor(
   chpl::ast::visitors::hpx::SymbolTable & st,
   ProgramTree & prgmTree,
   chpl::uast::BuilderResult const& chapelBr,
   std::string const& chapelFilePath,
   std::ostream & fstrm)
   : br(chapelBr), programTree(prgmTree), indent(0), scope(0), fstrm_(fstrm),
     chplFilePathStr(chapelFilePath),
     symbolTable(st),
     headers(static_cast<std::size_t>(HeaderEnum::HeaderCount), false)
{
}

static void upper(std::string & s) {
   std::transform(std::begin(s), std::end(s), std::begin(s), 
      [](const unsigned char c){ return std::toupper(c); } // correct
   );
}

void CodegenVisitor::generateApplicationHeader() {
   const auto pos = chplFilePathStr.find(".");
   std::string prefix = chplFilePathStr.substr(0, pos);

   std::ofstream os{prefix + ".hpp"};
   upper(prefix);

   os << "// This program file was generated by the chplx compiler." << std::endl;
   os << "//" << std::endl;
   os << "#pragma once" << std::endl << std::endl;
   os << "#ifndef __" << prefix << "_HPP__" << std::endl;
   os << "#define __" << prefix << "_HPP__" << std::endl << std::endl;

   for(std::size_t i = 0; i < static_cast<std::size_t>(HeaderEnum::HeaderCount); ++i) {
      if(headers[i]) {
         if(i == static_cast<std::size_t>(HeaderEnum::std_vector)) {
            os << "#include <vector>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_complex)) {
            os << "#include <complex>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_string)) {
            os << "#include <string>" << std::endl;
         }
      }
   }

   os << std::endl << "#endif" << std::endl;

   os.flush();
   os.close();
}

struct StatementVisitor {
   
   void emitIndent() const {
      for(std::size_t i = 0; i < indent; ++i) {
         os << INDENT; 
      }
   }

   template <typename T>
   constexpr void operator()(T const& kind) {}

   void operator()(std::shared_ptr<StatementList> const& node) {
      auto & list = *node;
      for(auto & stmt : list.statements) {
         std::visit(*this, stmt); 
      }
   }
   void operator()(ScalarDeclarationExpression const& node) {
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }
   void operator()(ArrayDeclarationExpression const& node) {
      headers[static_cast<std::size_t>(HeaderEnum::std_vector)] = true;

      std::shared_ptr<array_kind> const& akref =
         std::get<std::shared_ptr<array_kind>>(node.kind);

      if(!headers[static_cast<std::size_t>(HeaderEnum::std_complex)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_complex)] =
            std::holds_alternative<complex_kind>(akref->kind);
      }
      if(!headers[static_cast<std::size_t>(HeaderEnum::std_string)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_string)] =
            std::holds_alternative<string_kind>(akref->kind);
      }

      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }
   void operator()(ScalarDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
      os << " = ";
      std::visit(ScalarDeclarationLiteralExpressionVisitor{(*s->literal)[0], os}, node.kind);
      os << ";" << std::endl;
   }
   void operator()(ArrayDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }

   SymbolTable & symbolTable;
   chpl::uast::BuilderResult const& br;
   std::ostream & os;
   std::size_t indent;
   std::vector<bool> & headers;
};

template<>
void CodegenVisitor::visit(StatementVisitor && v) {
   for(Statement const& stmt : programTree.statements) {
      std::visit(v, stmt);
   }
}

void CodegenVisitor::visit() {
   visit(StatementVisitor{symbolTable, br, fstrm_, indent, headers});
}

} /* namespace hpx */ } /* namespace visitors */ } /* namespace ast */ } /* namespace chpl */
